《Java 程序设计教程》

# 第1章 基本概念

==知识点==
- 计算机系统由硬件和软件组成，软、硬件协同工作帮助我们解决问题。
- CPU 从主存储器中读取程序的每一条指令，并且每次执行一条指令直到程序结束。
- 操作系统提供用户界面并管理计算机资源。
- 对于用户来说，界面就是程序。
- 数字计算机存储信息的方式是将其分割成片断，并用一个数值表示每一个片断。
- 二进制用于在计算机存储和移动信息，这是因为存储和管理二进制数据的设备便宜且可靠。
- N 位二进制数有2的 N 次方种排列组合。因此，N 位二进制数可以表示2的 N 次方个不同的项。
- 主存储器和 CPU 构成了计算机的核心。主存储器用于保存程序和数据，而 CPU 执行程序指令。
- 地址是与每一个存储单元相关联的一个唯一值。
- 主存是不稳定的，仅当有电力供应时，数据和信息才得以保存。
- CD 表面具有光滑区和微小的凹点。凹点代表二进制1，光滑区代表0。
- 取指-译码-执行的循环构成了计算机处理的基础。
- 网络就是将两台或多台计算机连接在一起，以便实现信息交换。
- 同享一条通信线路将导致延迟、但是可以降低成本，并且使得在网络中加入新计算机更加容易。
- 局域网（LAN）是组织内部实现信息和资源共享的有效方式。
- 因特网是覆盖全球的广域网。
- 每一台连接到因特网的计算机，都有一个唯一标识自己的 IP 地址。
- 万维网是使人们更加容易地共享网络资源信息的软件。
- URL 唯一地指定了浏览器将寻找并显示的文档和其他信息。
- 注释本身不影响程序的执行，但可以帮助人们理解程序。
- 内嵌的程序注释要说明代码的内层含义，不能含糊不清或者仅从字面解释浅显的代码。
- Java 是大小写敏感的。同一单词的大写和小写形式不同的。
- 标识符名称应该具有描述性和可读性。
- 合理使用空白符，可以使程序更加可读和易懂。
- 程序员应当遵循一些建立程序书写格式及文档的规范。
- 为了能够执行，所有的程序都必须翻译成特定 CPU 的机器语言。
- 高级语言使程序员无须了解机器语言的底层细节。
- Java 编译器将 Java 源代码编译成 Java 字节码，这是一种低级的、具有独立结构的程序表示方式。
- 各种不同的 Java 开发环境，都有助于开发和修改 Java 程序。
- 语法规则规定了程序编写的形式，语义则是每条语句的含义。
- 程序员必须对程序的正确性和可靠性负责。
- Java 程序必须语义正确，否则编译器将不会产生字节码。
- 面向对象编程方法有助于解决问题，这正是编写程序的目的所在。
- 程序设计包括将一个大问题分解成若干个易求解的小问题。
- 每个对象都有自己的状态和行为，状态由对象的属性定义，而行为由对象的方法定义。
- 类就是对象的蓝图。由一个类定义可以得到多个对象。

## 对象

> 每个对象都有自己的状态和行为，状态由对象的属性定义，而行为由对象的方法定义。

## 属性

## 方法

## 类

> 类没有存储数据的空间，而每个对象都有自己存储数据的空间，这就是为什么每个对象能具有自己的状态。

> 类就是对象的蓝图。由一个类定义可以得到多个对象。


## 封装

> 对象必须封装起来，这意味着对象要保护并管理自己的信息。也就是说，对象是自我管理的，只有通过对象的方法才能改变对象的状态。设计对象时，要保证其他对象不能访问或改变该对象的状态。


## 继承

## 多态

> 多态是指用一种统一的方式引用有继承关系的不同类型的对象。

# 第2章 数据与表达式

==知识点==
- print 和 println 方法代表 System.out 对象提供的两个服务。
- 转义序列用于表示可能会导致编译错误的特殊字符。
- 变量为某个内存位置的名称，用于保存特定数据类型的值。
- 读取数据并不会改变它在内存中的值，但赋值语句会覆盖旧数据。
- 不允许将一个值赋给一个类型不兼容的变量。
- 常量于存在期间保存着一个特定的值。
- Java 有2种基本的数值型：整型和浮点型，其中包括4种整型和2种浮点型。
- Java 使用16位 Unicode 字符集表示字符。
- 表达式是运算符合操作数按一定规则构成的组合，用于完成计算。
- Java 遵循一组定义良好的优先级规则，这组规则控制了表达式的求值顺序。
- 压缩类型转换将丢失信息，因此应当避免使用。
- Scanner 类提供了一些从不同数据源读取各种类型数据的方法。

## 2.1 字符串

## 2.2 变量与赋值

> 变量为某个内存位置的名称，用于保存特定数据类型的值。

- 当引用一个变量时，它的值不会改变。

### 2.2.2 赋值

> 不允许将一个值赋给一个类型不兼容的变量。

### 2.2.3 常量

> 常量于存在期间保存着一个特定的值。

- 初始化赋值语句是唯一能改变常量值的地方。

## 2.3 基本数据类型

> 8种基本数据类型

### 2.3.1 整型与浮点型

- 整型：byte(8),short(16),int(32),long(64)
- 浮点型：float(32),double(64)

### 2.3.2 字符型

> 字符集是由字符按照一定顺序组成的一个字符列表。每一种编程语言都支持特定的字符集，用于定义有效的字符数据。ASCII（美国信息交换标准码）码字符集最为流行。

- Unicode（统一编码）字符集，16位。
-

### 2.3.3 布尔型

> 只有 true 和 false 两个值

## 2.4 表达式

> 表达式是运算符和操作数按照一定规则构成的组合，用于完成计算。

### 2.4.1 算术运算符

- 加减乘除+余
- Math类实现指数运算

### 2.4.2 运算符优先级

### 2.4.3 自增和自减运算符

```
x = i++ // 先把i赋值给x，i再加1。
y = ++i // i先加1，然后再赋值给y。
```

### 2.4.4 赋值运算符

```
total += 5 --> total = total + 5;

```

## 2.5 数据类型转换

> 扩展类型转换和压缩类型转换

- 注意：布尔型不能进行转换
- byte（8位）和short（16位）转换为char（16位）类型也是压缩类型的。

### 2.5.1 数据类型转换技术

- 赋值类型转换
- 提升类型转换
- 强制类型转换

## 2.6 交互式程序

### 2.6.1 Scanner类

> Scanner类提供了一些从不同数据源读取各种类型数据的方法。

```
import java.util.Scanner;

Scanner scan = new Scanner(System.in);

```

# 第3章 类与对象

==知识点==
- new 运算符返回对新建对象的引用。
- 多个引用变量可以引用同一个对象。
- 方法需由具体的对象调用，不同的对象决定着同一方法调用的不同结果。
- 开发程序是，类库提供了有用的支持。
- Java 标准类库是按包分组的。
- 对于每一个程序，java.lang 包中的所有类都将被自动载入。
- 伪随机数发生器通过执行复杂计算来产生模拟随机数。
- Math 类的所有方法都是静态方法，通过类名称即可调用它们。
- 在 Java 中增加 printf 方法，是为了支持遗留系统的移植。
- 枚举类型是安全的，保证了不会使用无效值。
- 包装器允许将基本类型数据作为对象管理。
- 祖东装箱提供了基本类型与相应的保证对象之间的自动类型转换。
- 现在，JavaFX 是用于开发使用图形和 GUI 的 Java 程序的首选工具。
- JavaFX 借用剧院演出的思想，在舞台上呈现不同的场景。
- Java 坐标系统的原点位于左上角。所有坐标值都是正值。
- 显示形状的顺序，与添加到组中的顺序一致，从而会使一个形状显示在另一个的前面。
- 形状和组可按需要平移与旋转。
- Java 用 RGB 值表示颜色。

## 3.1 创建对象

> System类是Java标准类库中的预定义类，用户直接使用不必定义。

```
System                -->   预定义类
System.out            -->   out对象变量
System.out.println()  -->   out对象的一个方法
```

> Java中，变量名可以代表一个基本数据类型或者一个对象。

```
// 两者比较
int num;            -->   声明一个基本数据类型
String name;        -->   声明一个对象变量，该变量保存了指向String对象的引用

// 只是声明，但实际上还不存在String对象。
num = 42;                            -->  给变量赋值
name = new String("James Gosling");  -->  给对象变量赋值，new实例化。

// 可以将声明和初始化对象合并为一步操作。
String title = new String("Java Software Solutions");

// 定义字符串常量。默认可以不用new来创建对象。
String city = "London";


```

- 对象变量不能保存对象本身，而是保存该对象的地址。
- 使用变量前先初始化是至关重要的。对于对象变量而言，这意味着在使用变量前，必须确保已经使该变量指向一个有效的对象。否则会报错！
- 可以将对象变量设置为null，表示该变量不指向任何对象。

> 使用new运算符创建对象的行为，称为实例化。

- 一个对象是一个类的实例。
- 要实例化对象，可以使用new运算符返回新对象的地址。即对象存储单元的指针。
- new实例化对象，调用类的构造方法。
- "."运算符，对象的方法。

### 3.1.1 别名

```
String name1, name2;

name1 = new String("Ada");
name2 = new String("Grace");

// 是地址复制。两者互为别名，它们是用一个对象的两个名字。name2的对象丢失，从此不能再使用，称为“垃圾”。
name2 = name1;   -->  两者都指向"Ada"

```

> 多个引用变量可以引用同一个对象。

- 所有与对象的交互都体现在使用对象变量上，所以其必须存在才能使用。
- Java会自动执行垃圾回收操作，将资源释放。

## 3.2 String类

> 一旦创建了String对象，该对象的长度就不可再改变，并且也不能修改对象中的任何一个字符。String类提供了几个方法可以返回新的String对象，这些新对象是对原对象字符串值修改的结果。

> 任何一次方法调用，必须由一个具体的对象来执行。方法需由具体的对象调用，不同的对象决定着同一方法调用的不同结果。

## 3.3 包

> Java API标准类库，可以根据需要直接使用。类库是由一套支持程序开发的类组成。编译器或开发环境通常以类库为基础。类库可以单独从第三方软件商获得。

- 类库由几组相关的类蔟构成，称Java API。
- Java 标准类库的类还被划分成包，每个类属于一个具体的包。

```
Java标准类库是按包分组的。

包          -->  类
java.lang   -->  String、System
java.util   -->  Scanner

```

## 3.3.1 import声明

> import声明指定了程序中要用的包和类。java.lang包中的类自动成为可用类。

```
// 程序必须引用完整的包名和类名。
java.util.Scanner scanner;

// import引入后，下面就可以直接使用Scanner类了。
import java.util.Scanner;

Scanner scanner;

// “*”引用包里面所有的类。
import java.util.*;


```

## 3.4 Random类

> 伪随机数发生器通过执行复杂计算来产生模拟随机数。随机性程度对于大多数情况已经足够满足需求。

```
import java.util.Random

Random generator = new Random();

int num1;
float num2;

num1 = generator.nextInt();
System.out.println("一个随机整数 " + num1);

num2 = generator.nextFloat();
System.out.println("零到壹的小数 " + num2);

```

## 3.5 Math类

> Math类方法都是静态方法，不用实例化，通过类名直接调用方法。

```
import java.util.Math


```

## 3.6 格式化输出

### 3.6.1 NumberFormat类

```
import java.text.NumberFormat

```

### 3.6.2 DecimalFormat类

```
import java.text.DecimalFormat

```

### 3.6.3 printf方法

> 方便C程序老系统的移植。尽量避免使用。

## 3.7 枚举类型

> 枚举变量。枚举类型是安全的，保证了不会使用无效值。Java内部，枚举型的每个枚举值保存为代表枚举值序数的整型数。枚举型是一种特殊类，枚举型变量是对象变量。不能将一个数值赋给一个枚举型变量。

```
// 定义枚举类型
enum Season {winter, spring, summer, fall};

// 声明枚举变量
Season time;

// 使用枚举变量
time = Season.spring;

```

## 3.8 包装（封装）器类

> 包装器类允许将基本数据类型数据作为对象管理。

```
基本数据类型  -->  包装器类
int           -->  Integer
void          -->  Void

```

### 3.8.1 自动装箱

> 自动装箱（autoboxing）是基本数据类型与相应的包装对象之间的自动转换。只能用于基本数据类型。

```
// 装箱 autoboxing
Interger obj1;
int num1 = 69;
obj1 = num1;

// 拆箱 unboxing
Integer obj2 = new Integer(69);
int num2;
num2 = obj2;

```

## 3.9 JavaFX

> JavaFX API 替换了 AWT 和 Swing。


```
// 继承了 Application类
extends Application


```

# 第4章 编写类

==知识点==
- 面向对象程序设计基于类的定义，类代表定义了合理的状态和行为的对象。
- 变量的作用域取决于声明该变量的位置，作用域确定了何处可以引用该变量。
- UML 类图有助于描述程序的类结构及类间的关系。
- 对象应封装起来，以防止对该对象的数据进行不适当的访问。
- 实例变量应将可见性声明为 private，以提高类的封装性。
- 大多数对象都有访问器和修改器方法，允许客户在一种受控方式下管理数据。
- 方法的返回值类型，必须与方法声明首部中规定的返回值类型一致。
- 调用方法时，将把实参复制给被调方法的形参。
- 在方法中声明的变量，只限于该方法内部使用。
- 构造方法没有任何返回类型，甚至没有 void 返回类型。
- 弧是当作椭圆的一部分定义的。
- 正的起始角和弧角值，是以逆时针方向度量的，负值表示顺时针方向。
- 图形用 Image 对象表示，但通过 ImageView 对象显示。
- 布局面板为一个 JavaFX 容器，它用特定方法管理节点的视觉呈现。
- 图形用户界面又控件、代表用户动作的事件和相应这些事件的处理器组成。

## 4.1 类与对象的核心概念

> 类是对象的蓝图。

- 对象是有状态的，状态由对象的属性值确定。对象的属性由类中所声明的变量定义。
- 对象还有行为，行为由对象可执行的操作确定。对象的操作由类中声明的方法定义。
- 注意，对象的操作可能改变对象的状态。

> 一个类需要哪些属性和操作，取决于程序设计者。

## 4.2 类的分析

> 每一个类都包含数据声明和方法声明。面向对象程序设计基于类的定义，类代表定义了合理的状态和行为的对象。

- 类的构造方法是一种特殊方法，其方法名和类名相同。

### 4.2.1 实例数据

> 变量声明的位置定义了该变量的作用域，作用域确定了变量在程序中可被引用的区域。Java自动初始化在类级声明的变量，但一般在构造函数中初始化。

### 4.2.2 UML类图

> UML类图对类和对象间的关系进行可视化描述。UML（Unified Modeling Language）。有助于描述程序类结构及类间的关系。

## 4.3 封装

> 对象必须是自我管理的。对象的实例数据只能由对象自己修改。对象应当封装起来，以防止对该对象的数据进行不适当的访问。Java使用修饰符实现对象封装。

### 4.3.1 可见性修饰符

> public、private、protected。实例变量应将可见性声明为private，以提高类的封装性。

- public供类外用户使用 -- 服务方法
- private供类内使用    -- 支持方法
- 一般常量设置为public final的，虽然可以直接访问但不能被修改。

### 4.3.2 访问器和修改器

> get方法称为访问器，set方法称为修改器。其中，修改要受控，修改合理。

## 4.4 方法的分析

```
// 修饰符 返回值类型 方法名（参数列表） [throws子句]
public void setFaceValue(int i) {
    faceValue = i;
}

```

### 4.4.1 return语句

> 方法的返回值类型，必须与方法声明首部中规定的返回值类型一致。构造方法没有返回值类型（也没有void型），因此不能返回值。

### 4.4.2 参数

> 参数是调用一个方法时传递给该方法的值。构造方法常常有参数。实参可以是常量值、变量或表达式。实参的类型必须与形参指定的类型一致。

### 4.4.3 局部数据

> 在方法中声明的变量，只限于该方法内部使用。不能从方法的外部引用该局部变量。

### 4.4.4 银行账户示例

==略==

## 4.5 构造方法

> 实例化对象时将调用构造方法。辅助创建类的实例。这个构造方法常用于初始化与每个对象有关的变量。

- 两点不同：
    - 构造方法名与类名相同；
    - 构造方法不能返回值，因此其方法声明首部中没有返回类型。没有void返回类型。
- 每一个类都有一个不带参数的默认构造方法。默认构造方法对新创建的对象一般没有影响。

# 第5章 条件判断与循环

==知识点==

- 条件语句和循环语句可用于控制程序的执行流程。
- if 语句可以使程序选择是否执行某一条语句。
- 循环可以使程序多次执行某些语句。
- 逻辑运算符经常用于构成复杂的条件。
- 编写语句时，适当的缩进格式能够增强程序的可读性；缩进格式体现了语句间的关系。
- if-else 语句可以使程序在某个条件表达式的值为 true 时执行一段代码，其值为 false 时执行另一段代码。
- 在一条嵌套 if 语句中，else 子句和它前面最近且未匹配的 if 语句相匹配。
- Unicode 字符集定义了 Java 中字符的相对顺序。
- compareTo 方法可用于判断两个字符串的相对顺序关系。
- while 语句执行相同的语句，直到它的条件变为 false。
- 必须精心设计程序，以避免无限循环。
- 迭代器是一个对象，可以用来处理相关的一组元素。
- 在 Scanner 对象中，用于分隔输入数据项的分隔符可以按需要显式地设置。
- ArrayList 对象保存着对象的列表并且可以用整型索引值来访问这些对象。
- 当创建 ArrayList 对象时，可存入到列表中的元素的类型也确定了。
- 可以用一个事件处理器处理由多个控件产生的事件。
- 应用于 Text、Label 或者 Button 对象的字体，是由 Font 类表示的。
- HBox 和 VBox 布局面板分别将它们的节点在一个行或列中放置。
- 单选钮组提供一组互斥的选项。

## 5.1 布尔表达式

> 语句顺序执行称为控制流。在一个给定的方法内，可以通过两类：条件语句和循环语句，控制程序的执行流程。

- 条件语句
    - if，根据布尔条件true或false来判断，来决定下一步要执行的语句。
    - if-else
    - switch

> 循环语句。重复循环执行。或者根据布尔条件判断，执行循环的次数。

- 循环语句
    - while
    - do
    - for
> 条件语句和循环语句中的布尔表达式，都是基于运算符来决定程序行为的。

- 相等性运算符
- 关系运算符
- 逻辑运算符

### 5.1.1 相等性运算符与关系运算符

```
==   等于
!=   不等于

<    小于
<=   小于等于
>    大于
>=   大于等于

```

### 5.1.2 逻辑运算符

```
!     逻辑非
&&    逻辑与
||    逻辑或

注意：&& 和 || 具有“短路”性的特点。

```

## 5.2 if 语句

5.2B 计算员工的工资例子略！

### 5.2.1 if-else 语句

5.2C 掷硬币例子略！

### 5.2.2 使用语句块

> 大括号括起来。

==5.2D Guessing==

### 5.2.3 嵌套 if 语句

注意：else 和最近的未匹配的 if 来配对。

## 5.3 数据比较

### 5.3.1 浮点数比较

> 浮点数比较不能相等，但可以与误差值进行比较。

```
// 近似相等
final fload TOLERANCE = 0.0001;
if (Math.abs(f1 - f2) < TOLERANCE)
    sout("Essentially equal.")

```

### 5.3.2 字符比较

> 字符比较转化成 Unicode。 来比较。数字在大写字母之前，大写字母在小写字母之前。字符和字符串比较方式不同。

### 5.3.3 比较对象

> String 字符串比较 equals 方法。
== 是比较地址是否引用了同一个 String 字符串对象。
String 的 compareTo 方法更加实用，判断两个字符串的相对位置。
字符和字符串比较都是以 Unicode 字符集为基础的。

```
if (name1.equals(name2)
    ...
else
    ...

String str = "software";
if (str == "software")
    sout("Reference are the same.")

if (str.equals("software")
    sout("Characters are the same.")

int result = name1.compareTo(name2);
if (result < 0)
    sout("name1 comes before name2.");
else
    if (result == 0)
        sout("The names are equal.");
    else
        sout("name1 follows name2.");

```

## 5.4 while 语句

> 判断布尔表达式的值 true 或者 false。

```
while 语句执行相同的语句，直到它的条件变为 false。

while (total > max) {
    total = total / 2;
    sout("Current total: " + total);
}

int count = 1;
while (count <= 5) {
    sout(count);
    count++;
}

```

- 例子：5.4A Average
- 例子：5.4B WinPercentage

### 5.4.1 无限循环

> 确保循环语句的判断条件最终会变为 false 是程序员的责任。

### 5.4.2 嵌套循环

> 外层循环执行一次，内层循环就会执行指定次数的完整循环。对于任何循环，都必须仔细检查循环控制条件和循环变量的初始值。

- 例子：5.4C PalindromeTester

### 5.4.3 break 语句与 continue 语句

> break 和 continue 语句会影响程序中的条件控制和循环。但应尽量避免使用。注意：switch 语句是必须用 break 语句的。

## 5.5 迭代器

> 迭代器是一个对象，该对象提供了一些方法有助于一次处理某个集合。Java 中的迭代器对象是用 Iterator 接口来定义的。

```
- hasNext 方法，返回布尔值，控制循环条件。
- next 方法，取得下一个要处理的元素。

迭代器使用场景，例如：处理一个数据文件中的各行数据，或者处理一个字符串的各部分。

```

### 5.5.1 读取文本文件

> Scanner 是一种迭代器，对象处理输入。Scanner 对象有 hasNext 、nextLine 和 next 方法。

- 例子：5.5A URLDissector

```
如：处理从文件读取行。注意：File 对象会抛出 IOException 异常。
Scanner line = new Scanner(new File("xxx.dat"));

处理每行的字符串。
Scanner word = new Scanner(line);

Scanner 对象默认下用空白字符（空格、制表符和空行）作为输入数据项的分隔符。也可以用useDelimiter方法来设置，甚至支持正则表达式。

```

## 5.6 ArrayList 类

> ArrayList 常常用来管理对象集--对象列表。

- 利用索引来访问，索引从0开始。
- 创建ArrayList 对象时，元素的类型也确定了。
- 元数保存的是元素的引用，所以不能保存基本数据类型，它们要转换成对象，如 ArrayList<Integer>。
- 例子：5.6A Beatles

# 第6章 其他条件判断与循环

==知识点==

- switch 语句将一个指定的字符或整型值分别与若干个 case 子句中的值进行匹配。
- break 语句常用来退出 switch 语句中的各个 case 子句。
- 条件运维符基于布尔表达式计算出两个可能的值中的一个。
- do 循环的循环体至少会执行一次。
- for 语句通常用于已知循环执行次数的情况。
- for 循环的 for-each 版本，简化了 Iterable 对象中元素的处理。
- 各种循环语句的功能等价的，使用哪种循环语句取决于具体的情况。
- 转换改变节点的视觉呈现。
- 在两个轴上采用相同的缩放因子，可使节点不变形。
- 对一个组或者面板应用的转换，都会自动适应于容器内的所有节点。

## 6.1 switch 语句

> 多条语句中选择一条来执行。虽然可以用 if 来改造，但 switch 语句更加简洁。

- switch 表达式运算结果必须是：char、byte、short、int或枚举型。Java7 增加了 String 类型。注意：不能是 boolean 或 float 型。
- switch 表达式只能是等值判断，if 就可以更加灵活。
- case 子句中的表达式必须为常量，不能为变量或其他表达式。
- default 语句建议要加上。
- break 语句一般都会有，确保只有一条能执行。

```
注意：switch 语句将一个指定的字符或整数值分别与若干个 case 子句中的值进行匹配。

switch(idChar) {
    case 'A':
        aCount = aCount + 1;
        break;
    case 'B':
        bCount = bCount + 1;
        break;
    default:
        sout("Error in Identification Character.")
}

```
- 例子：6.1A GradeReport

## 6.2 条件运算符

> 是三元运算符。if-else的另一种特例。它只是一个表达式，不是语句。一般不建议用，可读性不如 if-else 语句。

- 布尔条件，true 返回第一个，false 返回第二个。
- 冒号分开两个表达式。

```
total = (total > MAX) ? total + 1: total * 2;

sout("Smaller: " + (num1 < num2) ? num1 : num2);

```

## 6.3 do 语句

> 注意：循环体提至少会执行一次。

- do 包括循环体；
- 循环条件为 false 时退出。

```
int count = 0;
do
{
    count++;
    sout(count);
}
while (count < 5);

--------------------------------

do {
    sout("Enter a word: ");
    word = scanner.next();
    sout(word);
} while (!word.equals("quit"));

```

- 例子：6.3A ReverseNumber

## 6.4 for 语句

> for 语句通常用于已知循环执行次数的情况。

- 控制头包含三部分：
    - 初始化。（只执行一次。声明在这里的话，只能循环体内引用，只能由增量修改。）
    - 布尔表达式（判断：true执行、false退出。）
    - 增量。（循环体执行一次后，才执行增量。）
-

```
for (int count=1; count<=5; count++)
    sout(count)

```

- 例子：6.4A Multiples
- 例子：6.4B Stars

### 6.4.1 for-each 循环

> for-each 循环是 for 循环的增强版，特别处理迭代器对象，如 ArrayList。

- for-each 简化了 Iterable 对象中元素的处理。
- ArrayList 也是一种 Iterable 对象。

```
ArrayList libary = new ArrayList(...);

for (Book myBook: libary) {
    sout(myBook);
}

等价于下面的循环语句：

Book myBook;
while (bookList.hasNext()) {
    myBook = bookList.next();
    sout(myBook);
}

```

### 6.4.2 各种循环的比较

> 三种循环语句：while、do和for循环。

- 用哪一个循环，取决于具体的情况。
- while执行0次或多次，do执行1此或多次。
- while和for循环，都是先判断条件。for循环将控制变量从循环体中剥离出来。

# 第7章 面向对象设计

==知识点==

- 投入在软件设计上的努力是至关重要的且非常值得。
- 问题描述中的名词，可能指明了程序中需要的一些类和对象。
- 静态变量由类的所有实例共享。
- 一个聚合对象由其他的对象组成，形成一种“有”关系。
- 接口是抽象方法的集合，因而不能被实例。
- 枚举类型的值是具有该枚举类型的静态变量。
- 在枚举类型的定义中，可以增加属性和方法。
- 可以将对象提供的一个复杂服务，分解为由多个方法支持的简单服务。
- 将对象传递给方法时，形参和实参相互成为对方的别名。
- 多个重载方法可以由方法的参数个数、类型及参数顺序来区分。
- 程序测试无法保证程序已没有错误存在。
- 成功的测试，就是能够发现错误的测试。
- 对程序所有可能的输入数据和用户操作进行穷尽的测试，这是不现实的。
- 设计任何 GUI 程序，都必须坚持一致性和可用性原则。
- 移动和单击鼠标，都会产生程序可以响应的事件。
- “橡皮筋线”是一种视觉效果，当一个图形被鼠标拖拽时表现出伸缩状态，就产生了这种效果。
- 按键事件可以让程序快速响应用户按下的键盘键。

## 7.1 软件开发活动

> 软件开发所涉及的问题，远比代码编写的问题多。

软件开发4个基本过程：
- 确定软件需求
- 软件设计
- 实现软件设计
- 软件测试

> 过程总是相互重叠和交互的。

1. 程序设计实际上是关于问题的解决方法，编写程序是为了解决某个具体问题，软件需求这是对这个问题的清晰描述。
    - 用户接口问题，如输出格式、屏幕显示布局及图形接口组件；
    - 功能描述和性能描述；
2. 软件设计描述了如何完成需求所指定的任务，并定义了程序中需要的类和对象、类之间关系及类之间的交互。
    - 底层的设计将解决各个类的方法如何完成自己的任务。
    - 设计方案可能不是最优的，需要调整。
3. 实现是将设计转换成某种程序设计语言的行为。
4. 测试是抱着软件解决预定的问题，并能够满足性能要求。

## 7.2 明确类和对象

> 面向对象软件设计的基本内容就是确定类，类决定着软件的结构。必须仔细考虑如何表示形成整个问题解决方案的各种类。这些类也决定了软件系统要管理的对象。

- 明确类的方法，是识别出软件需求中所讨论的实体对象。
- 对象一般是名词，可以在需求分析文档中仔细查阅一个问题的描述或功能说明，从中发现这些名词。但不一定都与类对应，只是一个初步结果。
- 类代表了一组有相似行为的对象。
- 一般，名词代表一个类。
- 类识别，区别一个对象和另一对象的基础属性。
- 对于给定的程序需求，应在一般类和特殊类之间寻找一种平衡。
- 除了需求中的名词类外，还需要设计一些特殊类支持任务完成。
- 复用一些现有或第三方的类来设计。

### 7.2.1 类职责的分派

> 识别出程序所需要的类后，还要给每个类分派职责。

- 每个类代表一个具有某些行为的对象，对象的行为由这个类的方法定义。
- 每个类负责执行某些活动。
- 类的行为所执行的动作体现了程序的功能，通常是动词和完成行为的方法命名。
- 设计某个类的特殊职责具有很大的挑战性，这时应该考虑多种选择的可能性。
- 开始没必要把所有的方法都考虑到，基本的设计即可。

## 7.3 静态类成员

> 静态方法是通过类名而不是对象来调用的，如 Math 类中的方法都是静态方法。static 保留字。

- 静态方法
- 静态属性

### 7.3.1 静态变量

- 方法中的变量；
- 类中且方法外的变量 --> 实例变量，每个实例有自己的副本；
- static 静态变量 --> 类变量，所有的类实例共享；

```
class ... {
    private static int count = 0;
    ...
}

注意：
- 第一次引用类时，将为静态变量分配内存；
- final static 静态常量，所有实例只存在一个常量。

```

### 7.3.2 静态方法

- 通过类名来调用方法，不用实例化对象。
- main 方法为 static 静态方法，执行时不用实例化。所以 main 方法只能使用静态变量或者局部变量。
- 静态方法不在一个具体对象的上下文环境中操作，因此不能使用实例变量。可以使用静态变量。
- 例子：7.3A SloganCounter

## 7.4 类之间关系

> 三种基本关系：依赖、聚合和继承。

### 7.4.1 依赖关系

- A类调用B类的方法。
- A类中引用B类对象，就获得了对象访问权。
- A类的方法，B类的对象作为参数。

> 通常，应当最小化类间的依赖关系强度。类之间的依赖关系越少，软件系统代码修改所带来的影响和错误就会越小。

### 7.4.2 同一个类的对象之间的依赖性

> 一个类代表一个具体的对象。

```
String 类的 concat 方法，其接收 String 类的实例为参数。

str3 = str1.concat(str2);

```

- 例子：7.4.2A RationalTester

### 7.4.3 聚合

> 有些对象是由其他对象构成的。描述为『有』的关系。对象越复杂，越可能是一个聚合对象。

- 聚合关系是依赖关系的特殊类型。
- 聚合通常要调用组成类的方法。
- 例子：7.4.3A StudentBody

### 7.4.4 this 引用

> Java 的保留字，this 引用允许对象引用自己。非静态方法需要通过具体的对象或者类来引用，this 引用可用于引用当前正在运行的对象。

- 常用于类构造函数中对类属性的初始化赋值。


## 7.5 接口

> 接口表示一组公有的方法，通过这组方法可以与对象交互。Java 接口是抽象方法的集合，因而不能被实例化。

- Java 接口是一组常量和抽象方法的集合。
- 抽象方法是没有实现的方法，即抽象方法没有代码体，包含参数列表的方法声明头后面仅有一个分号。
- 接口不能被实例化。

```
public interface Complexity {
    public void setComplexity(int complexity);
    public int getComplexity();
}

```

- 例子：7.5A MiniQuiz


- 抽象方法的保留字 abstract，但接口中的方法是 public。
- 类通过实现定义在接口中的每个抽象方法来实现这个接口。
- 实现接口的类（即实现类）在类声明头部使用保留字 implements，接着再给出接口名。
- 类提供接口中所有方法的实现代码。注意：是所有不能剩一个。
- 接口和实现该接口的类的关系可以用 UML 类图表示。


- 多个类可以实现同一个接口，同一方法但有不同的定义；
- 一个类可以实现多个接口，用逗号分隔；
- 接口中可以有 final 定义的常量；

> 接口定义了用户与实现类进行交互的方式 --> 多态性。

### 7.5.1 Comparable 接口

> Comparable 接口，其中 compareTo 方法，两个对象比较。

- String 类实现了 compareTo 接口方法，实现了字符串对象的比较。

```
public final class String
extends Object
implements Serializable, Comparable<String>, CharSequence

```

### 7.5.2 Iterator 接口

> 接口，由代表一个对象集合的类使用，提供了在对象集合中每次操作一次移动到下一个对象的方法。

- 大多数迭代器是利用 Iterator 接口定义的，如 Scanner 对象。
- Iterator 接口有两个主要的方法是 hasNext 和 next。
- Iterator 接口有 remove 方法来删除对象。

```
public final class Scanner
extends Object
implements Iterator<String>, Closeable

```

## 7.6 枚举类型

> 枚举类型是一种特殊的类。枚举类型的值是对象。

```
enum Season {
    winter, spring, summer, fall
}

Season time;

time = Season.spring;

```

- time 为枚举类型的变量；
- time 为 Season 类的对象；
- time 的值只能是 Season 类定义中的值；
- 这些值，是 Season 类的静态变量；


- 例子：7.6A SeasonTester

> 在枚举类型的定义中，可以增加属性和方法进行扩展。

## 7.7 方法设计

> 完成类的识别及基本职责分派后，对方法的设计。

- 算法是对解决一个问题的步骤和过程的描述。
- 每一个方法将实现一个算法，而算法决定了方法如何达到它的最终目的。
- 通常用伪码来描述算法，伪码是一种形式语句和英语短语相结合的表达方式。

### 7.7.1 方法分解

> 区分哪些 public 方法对外服务，哪些 private 方法对内服务。

- 例子：7.7.1A PigLatin

- 将复杂的方法进行分解。

### 7.7.2 方法参数的传递方式

- 参数传值，将实参的副本传递给形参。方法内部的修改对实参没有影响。
- 参数传对象，实参和形参地址指向是同一个对象，方法内改变了对象的状态，实参也改变了。只是改变了形参的引用，则实参对象不改变。


- 例子：7.7.2A ParameterTester

## 7.8 方法重载

> 方法名相同的方法。编译器对应匹配方法，即方法的签名。不能产生歧义。返回值的类型不能作为区别依据。构造方法经常使用重载方法。

- 参数个数不同
- 参数类型不同
- 参数顺序不同

## 7.9 测试

- 发现问题的活动；
- 改进系统质量评估；

> 测试的目标是发现错误，并修正错误，逐步提高程序质量。

- 特定的输入数据运行程序并产生正确的结果；
- 设计测试用例；
- 解决问题后重新跑测试用例的过程，即回归测试。

### 7.9.1 评审

> 一种用于评价设计和代码的技术，称为评审。评审的目的是发现问题，不是解决问题。有时将评审成为走查。

- 开会形式，审阅设计文档或程序代码段；
- 陈述自己的设计或代码，听取其他人建议；
- 讨论设计或代码的优点与问题，列出必须考虑解决的问题清单；
- 设计评审时，考虑是否完整地考虑了所有的需求，系统分解为类和对象的方法进行评估；

### 7.9.2 缺陷测试

> 由于测试的目的是发现错误，因此称为缺陷测试。发现和修正错误来增强系统的可靠性，而不是将错误留给用户去发现。

- 一个测试用例由一组输入数据、用户操作或其他初始条件及期望输出构成。
- 测试用例形成规范的文档。
- 建立一套完成的测试方案，由覆盖了系统各个方面的测试用例组成。

> 测试每一种情况是没必要的。两种缺陷测试的方法：黑盒测试和白盒测试。必须先确定期望输出的结果。

- 黑盒测试
    - 不考虑内部实现，基于输入和输出数据；
    - 重点是类的系统接口（类的公有方法）；
    - 由系统的需求分析或方法的功能描述直接导出；
    - 等价类。取边界值和普通值。
- 白盒测试
    - 也称玻璃盒测试。
    - 测试方法的内部结构和实现。
    - 以代码逻辑为基础。
    - 保证每条路径至少执行一次。也称为语句覆盖。
    - if 或 while 等语句设计输入值。

# 第8章 数组

==知识点==

- 具有 N 个值的数组索引为0~（N-1)。
- 在 Java 中，数组是必须实例化的对象。
- 数组边界检查保证引用一个数组元素的索引值在有效范围内。
- 初始值表可以用于实例化一个数组对象，这时不再需要用 new 运算符创建数组对象。
- 整个数组可以作为一个参数传递给方法，使得方法的形参成为原始数组的别名。
- 实例化对象数组只是为保存对象应用而预留空间，对每个数组元素所代表的对象必须分别实例化。
- 命令行实参存储在 String 对象的数组中，并将传递给 main 方法。
- 可以将 Java 方法定义成参数个数可变的方法。
- 在面向对象的系统中，很少使用高于二维的多维数组。
- 折线与多边形类似，不同之处在于折线不是一个封闭的图形。
- 选项框为用户提供下拉菜单选项。


> 需要将对象或基本数据类型数据组织成某种形式，以便于访问和修改。如：ArrayList 类。

- 数组是一种可将数据分组为数据表的结构。

## 8.1 数组元素

> 数组是一个含有多个值得列表，每个值存在于数组中特定的、具有编号的位置。对应每个位置的编号称为索引或下标。

- 索引从0开始；
- 访问值：数组名[索引]；
- 0~(n-1)个值；
- 索引是整型值；
- 数组在内存中是连续存放的，从左至右顺序存放；
- 元素地址的计算 = 该数组元素的索引值 * 每个元素所占的字节数 + 数组起始地址。

## 8.2 声明和使用数组

> 数组是对象。必须声明引用变量。new 运算符实例化数组，为数组分配内存空间。Java 中，数组是必须实例化的对象。

```
// int[] 声明中未指定大小，但 new int[11] 之后大小就不能再改变了。
int[] height = new int[11];

```

- 数组可以保存任何基本数据类型或者对象。
- 保存在数组中的值也称数组元素。
- 值得类型称为数组元素类型。
- []运算符有最高的优先级。


- 例子：8.2A BasicArray

> 每个 Java 数组都是迭代器。

### 8.2.1 边界检查

> Java 自动执行边界检查。否则抛出 ArrayIndexOutOfBoundsException 异常。

- 数据的个数 length；
- 最大索引值 length-1；


- 例子：8.2A ReverseOrder 数组倒序
- 例子：8.2B LetterCount 字母统计

### 8.2.2 数组声明方式

```
// 两种声明方式等价的。
int[] grades; // 推荐
int grades[];

```

### 8.2.3 数组初始值表

> 使用数组初始值表{}，不需要再使用 new 运算符。

```
// 数组的长度由初始化值表中的数据项数确定。
int[] scores = {1, 2, 3, 4,5};

// 类型必须匹配
char[] vowels = {'A', 'E', 'I', 'O', 'U'};

```

- 例子：8.2.3A Primes数组初始化表

### 8.2.4 数组作为参数

> 数组作为参数传递给方法。和对象一样处理。

## 8.3 对象数组

> 对象数组可以建立有相当复杂度的信息管理结构。

```
// 每个元素也是一个对象。没有创建任何 String 对象，只是建立一个可保存 String 对象引用的数组。
String[] words = new String[5];

words[0] = "AAA";

// String 字符串是字符串常量。利用初始值表声明。
String[] verbs = {"play", "work", "eat", "sleep"};

```

- 例子：8.3A GradeRange
- 例子：8.3B Movies

## 8.4 命令行实参

> 命令行实参存储在 String 对象的数组中，并将传递给 main 方法。

- args 数组要有足够的元素，否则抛 ArrayIndexOutOfBoundsException 异常；
- 参数总是 String 对象数组，如果是数值型参数，须 String 转化为数值型。
- 例子：8.4A NameTag

## 8.5 可变长度参数表

> Java 方法定义成参数个数可变的方法。

```
// ... 表示参数个数是可变的；
// 个数包括0个；
// 参数自动存入 list 数组，转为对数组进行处理。
public double average (int ... list) {
    double result = 0.0;

    if (list.lengh !=0) { // 因为参数可以为0个，所以要判断一下先。
        int sum = 0;
        for (int num: list)
        sum += num;
        result = (double)sum/list.length;
    }

    return result;
}

// 参数可以是基础类型，也可以是对象类型。
public void printGrades (Grade ... grades) {
    for (Grade letterGrade: grades)
        sout(letterGrade);
}

// 方法还可以同时接收其他参数；
// ... 要写在最后面；
// 不能有两个 ... 参数。
public void test (int count, String name, double ... nums) {
    // whatever
}

```

- 例子：8.5A VariableParameters

## 8.6 二维数组

> 二维数组有二维的值，即行和列构成的表。必须有两个索引值。int[][]。

- 例子：8.6A TwoDArray
- 注意，外循环和内循环的控制。
- 二维数组初始化也可以是初始值表来定义。
- 例子：8.6B SodaSurvey

## 8.6.1 多维数组

> 一般用二维数组，多维数组谨慎使用。即保存数组对象引用的数组。

# 第9章 继承

==知识点==

- 继承就是从现有类派生新类的过程。
- 继承的目的之一就是复用现有软件。
- 继承在父类和子类之间建立一种“是”关系。
- protected 可见性提供了允许继承的最大可能的封装性。
- 使用 super 引用可以调用父类的构造方法。
- 子类方法可重写（重定义）它所继承的父类方法。
- 一个类的子类还可以是一个或多个其他类的父类，由此建立起类层次结构。
- 应当合理地将类的共同特性保持在尽可能高的类层级上。
- 所有的 Java 类都直接或间接地由 Object 类派生。
- Java 程序的每一个类都继承 toString 方法和 equals 方法。
- 不能实例化抽象类。抽象类代表一种概念，子类将基于这种概念来定义方法。
- 由抽象类派生的子类必须重写所有父类的抽象方法，否则子类仍然是抽象类。
- 继承的概念可以应用到接口，以便由一个接口派生另一个接口。
- 父类的私有成员也被子类继承，虽不能以成员名直接访问这些私有成员，但可以间接访问。
- 软件设计中必须特别精心地研究和设计类间继承关系的层次结构。
- final 修饰符可用于限制继承。
- 定义 JavaFX 场景节点的类，组成了一个类层次结构。
- 颜色和日期选择器为控件，分别允许用户指定颜色和日期。
- 对话框是一种弹出窗口，提供简要的、特定的用户交互操作。
- 文件选择器的外观，与底层平台有关。
- 继承是组织和创建类的基本技术，它功能强大。
- 面向对象软件的设计，并增强了类的复用性。

## 9.1 创建子类

> 类建立了对象的特征和行为，并没有为声明的变量预留内存空间（除非所声明的变量是静态的）。继承就是从现有类派生新类的过程。

- 继承的目的之一就是复用现有类。
- 一般，继承类更快捷、更容易且成本更低。
- 用于派生的原始类称为父类、超类或基类。
- 被派生出的类称为子类或亚类。
- 保留字 extends。
- 两个类是“是”的关系。“X是一种Y”，是继承关系。
- 例子：9.1A Words

> 子类的实例化并不依赖于父类的实例化。继承具有单向性。

- 父类不能引用在子类的变量和方法。

### 9.1.1 protected 修饰符

> 父类的 protected 属性和方法，可以被子类直接使用。同一个包内的类引用。

- 父类所有的属性和方法（包括private，只是不能被子类引用而已）都被子类继承。
- 构造方法不能被继承。构造方法是一种特殊的方法，用于创建一个具体类型的对象。
- 所以子类没有必要继承父类的构造方，但是，子类可能需要引用父类的构造方法，使用 super 引用。

### 9.1.2 super 引用

> super 引用的用处之一是调用父类构造方法。

- super 函数只能在子类中出现；
- 必须在构造函数的第一行调用 super() 函数；
- super 也可以调用父类的其他变量和方法。
- 例子：9.1.2A Words2

### 多继承

> Java 的继承方法称为单继承，即子类只能有唯一的父类。

- Java 中可依赖接口提供多继承的最好特性而不会增加歧义性。

## 9.2 重写方法

> 当子类与父类有相同的方法名和签名时，子类方法将重写父类方法。

- 子类方法优先。
- 重写一般发生在继承的场景。
- 例子：9.2A Messages

> 调用方法的对象决定了哪一个版本的方法将被实际执行。

- final 修饰的方法将不能被子类重写。

### 9.2.1 影子变量 shadow variable

> 子类与父类的同名变量。（原则上应该避免！）

## 9.3 类层次结构

> 类的继承关系常发展成为一个类层次结构。

- 子类个数和类层次数都没有限制。
- 同一个父类的两个子类，称为同胞。尽管二者有些相同的特征，但同胞之间没有继承关系。
- 公共特征保持在类层次的高层级上。最大化复用类。
- 父类变化，会反映到所有的子类上。
- 始终保持父子类之间是“是”的关系。

> 类的继承机制具有传递性。

- 设计类层次结构所做的决策，会制约与指导着底层更细节的设计决策和实现方案的选择，因此设计类层次时必须小心。
- 采用哪种类层次结构用于解决某种具体问题是最佳的选择，必须根据程序的需要而定。

### 9.3.1 Object 类

> Java 中，所有的类归根结底都由 Object 类派生。

- 没有 extends 子句的类，默认继承至 Object 类。
- Java 所有类都是 Object 类的子类，所以继承了 public 方法。

```
class Thing { // whatever}

等价

class Thing extends Object { // whatever }


Object 类的 public 方法：
equals()
toString() // 默认返回对象名@唯一标识数值，一般可以根据自己需要进行重写。
clone()

```

### 9.3.2 抽象类

> abstract 抽象类不能实例化。抽象类代表一种概念，子类将基于这种概念来定义方法。

- 含有抽象方法，但不必一定包含抽象方法。
- 与接口类似，但区别是：抽象类可以含有非抽象方法和变量。

> 抽象类在类层次结构中充当占位符。

- 抽象类在类层次结构上的定义位置不受限制，但一般设计在较高的类层次上。
- 从非抽象类父类派生出抽象类也是可能的。
- 子类完成抽象父类中的抽象方法 --> 方法重写。

> 如果子类没有完成所有的抽象方法的话，子类也是抽象类。

==注意==
- 抽象方法不能用 final 修饰符。因为子类将无法重写。
- 抽象方法不能用 static 修饰符。因为通过类名调用方法却没有实现方法的内容。

> 选择哪些类和方法作为抽象类和抽象方法，是软件设计过程中的重要环节，需要仔细考虑后再做出选择。通过抽象类，建立灵活的和可扩展的软件系统。

### 9.3.3 接口层次

> 接口可以继承，一个接口可以派生另一个接口。

- 子接口继承了父接口的所有抽象方法和常量。实现类必须实现所有接口。
- 接口都是 public 的。
- 接口不能派生新类，类也不能用于派生接口。
- 类只能实现接口，二者才有交互。

## 9.4 可见性

> 注意：父类的所有变量和方法都将被子类继承，包括父类的私有成员（子类不能直接使用，但可以间接地引用！）。

- 例子：9.4A FoodAnalyzer

## 9.5 继承关系的设计

> 精心研究和设计继承关系的层次结构。

### 9.5.1 继承的限制

> final 修饰符可限制继承，防止子类做修改。恰当的利用 final 很关键。

- final 修饰符的方法，确保所有子类必须使用。

```
// final 类不能用于派生新类。但此类可以正常使用。
public final class Standards {
    // whatever
}

```

# 第10章 多态性

==知识点==

- 多态性引用能够随时间变化指向不同类型的对象。
- 对于多态性引用，方法调用与方法定义代码的绑定在运行时执行。
- 一个引用变量可以指向有继承关系的任何类的任何对象。
- 实际将调用的方法版本，取决于对象的类型而不是引用变量的类型。
- 接口名可以用于声明对象引用变量。
- 一个接口引用变量可以指向实现该接口的任何类的任何对象。
- 方法的参数可以是多态性的，使得方法所接收的参数具有灵活性。
- 以多态性方式实现的排序算法，可对任何一组可比较的对象排序。
- 多态性允许用一致性的方法实现不一致的行为。
- 应该训练自己的软件设计敏感性，善于识别能利用多态性解法的潜在问题。
- JavaFX 类中的许多值都是用属性管理的，属性可以相互绑定。
- 属性绑定专门针对数据同步需求，不能用它替换事件处理器。
- 滑动条允许用户在一个有限的取值范围中指定一个数值。
- 微调器允许用户从一组预定义的选项中，通过箭头选择一个值。
-

## 10.1 后绑定

> 多态性引用能够随时间变化指向不同类型的对象。

```
一般，一个引用变量的类型与要引用的对象的类型匹配。但实际上不是必须的，类型不用完全相同，只要兼容即可，二者关系可以很灵活。
ChessPiece bishop;

```

- 多态性可以理解为“有许多形式”，一个多态性引用是可以在不同时间指向不同类型对象的引用变量。

```
// obj 引用是多态的，不同的时刻指向不同的对象。
obj.doIt()

```

- 一个方法调用与一个方法定义的绑定。一般，这种绑定发生在编译阶段。
- 但对于多态性，这种绑定要延迟到程序运行时才能执行，并且要绑定的方法定义取决于当时引用变量所引用的对象。这一被延迟的请求事件称为后绑定或者动态绑定。
- 后绑定的效率低于编译阶段的绑定效率，动态绑定会带来开销，但多态性提供了灵活性牺牲一点效率。

> 对于多态性引用，方法调用与方法定义代码的绑定在运行时执行。

- 例子：10.1A Firm
- 多态性的本质是，每个类很清楚自己如何完成一个指定的行为。
- 多态机制允许有一致性但又独特的方式处理类似的对象。

## 10.3 利用接口实现多态性

> 接口名可以用于声明对象引用变量。

```
// 声明一个接口。
public interface Speaker {
    public void speak();
    public void announce(String str);
}

// 声明一个对象引用的变量。
// 引用变量 current 可以指向实现 Speaker 接口的任何类的任何对象。
Speaker current;

// 如实现类 Philosopher，就可以将 Philosopher 对象赋给 Speaker 接口引用变量。
current = new Philosopher();

```

> 实现类与其接口之间有一种“是”的关系，这种关系奠定了多态性的基础。

- 一个接口引用变量可以指向实现该接口的任何类的任何对象。
- 接口引用的灵活性使我们能够创建多态性的引用。
- 利用继承建立多态性引用，可指向一组有继承关系对象中的任何一个对象。

```
// 同一个接口引用变量可以在某时刻指向一个对象，之后某一时刻又指向另一个对象。
Spearker guest;

guest = new Philosopher();
guest.speak();

guest = new Dog();
guest.speak();

// 转化类型
((Philosopher)special).pontificate();

```

- 调用的方法取决于发生时接口引用所指向的对象的类型。
- 当使用接口引用变量时，只能调用定义在接口中的方法，即使用接口引用变量所指向的对象还有其他一些可用的方法，也不能调用。
- 某种情况下，可以进行适当的对象类型转化，使得编译器能接受这个调用。

> 方法的参数可以是多态性的，使得方法所接收的参数具有灵活性。

- 像基于继承的多态性引用一样（父类名可用作方法参数的类型），接口名也可以用作方法参数的类型，使得任何实现同一接口的类对象都可以作为参数传给方法。

```
public void sayIt(Speaker current){
    current.speak();
}

```

## 10.4 排序

- 例子：10.4A PhoneList
- 选择排序和插入排序效率相同，都是 n2 阶算法。
- 但选择算法所执行的交换操作次数更少，所以选择排序优于插入排序。

## 10.5 搜索

### 10.5.1 线性搜索

> 从一个端点开始，以线性方式扫描整个搜索池，称为线性搜索。相对比较简单。

- 例子：10.5.1A

### 10.5.2 二分法搜索

> 如果一个数组中的元素是有序的（升序或降序），则二分法搜索比线性搜索算法的效率高很多。二分法搜索利用搜索池是有序的这一事实，减少了大量的比较操作。

- 例子：10.5.2A

### 10.5.3 搜索算法的比较

- 二分法搜索比线性搜索效率高，但二分法搜索要求数据已做过排序。表明，算法的选择取决于具体条件。
- 如果数据排序相对容易或者数据的搜索量非常大，则使用二分法搜索较合适。
- 但线性搜索的实现相对简单，若效率不是问题的情况下，线性搜索则可能是最佳的选择。

## 多态性设计

> 多态性允许用一致性的方法实现不一致的行为。

- 对于面向对象软件设计的每一方面，都需要我们精心、仔细地做出决策，这些决策将导致良好的软件结构、高度的软件灵活性和高质量的代码。
- 软件设计时应合理地定义有恰当封装的类和对象、建立类之间和对象之间的适当关联关系，包括根据可能性建立类间承上启下的继承关系。
- 多态性也是辅助分析软件设计的有效工具之一。
- 多态性支持软件功能实现方式的多样化，允许用一种统一形式的方法完成一组具有不同行为的类似功能。
- 软件设计者应尽可能从软件系统中发现能利用多态性解决问题的机会，在开始编码写代码前就需要积极主动地挖掘体现多态性的问题。
- 每当发现不同类型的对象执行相同类型的行为时，就存在着利用多态性方法的机会。
- 经验越多，就越容易发现多态性机会。
- 特点是，多个不同对象执行相同的基本行为，并且行为的不同实现方式取决于对象的具体类型。

> 应该训练自己的软件设计敏感性，善于识别能利用多态性解法的潜在问题。

- 一旦识别出多态性问题后，就需要进一步考虑多态性设计的具体方法，即需要确定使用继承机制还是接口机制定义多态性引用。
- 问题的答案取决于所涉及的各种类型对象间的关系。
    - 如果对象可以自然由继承的关系关联在一起，即对象间具有真正的“是”关系，则通过继承实现多态性；
    - 如果对象共同存在的主要问题需要以各自不同的方法进行处理，则通过接口建立多态性引用。

## 10.7 属性

> JavaFX 类中的许多值都是用属性管理的，属性可以相互绑定 bind。

- 属性是一种包含值的对象，与包装器类相似。
- 属性是可观察的，表示在必要时可以监控和改变属性值。
- JavaFX，不是保存 int 或者 Integer 对象，而是一个 IntegerProperty 对象。
- 属性的主要好处是“绑定”的概念。将一个属性与另一个属性绑定，这样，当一个属性的值发生改变时，另一个会自动更新。

```
// 注意，程序中并没有提供任何事件处理器。属性绑定关注的是场景中元素的所有动态更新。但是要注意，属性绑定并不总是能够替换事件处理器。绑定使数据同步，而事件处理器是一段代码，用于处理发生事件时希望达到的效果。因此，事件处理器的功能更强大。

```

> 属性绑定专门针对数据同步需求，不能用它替换事件处理器。

### 10.7.1 变化监听器

- 属性有一个变化监听器，它与事件处理器相似，但可以随意对其指定代码。
- 如果希望响应属性值的变化，且希望做一些比同步两个数据更多的事情，则可以采用变化监听器。
- 属性具有一个 addListener 方法，可以来设置属性的变化监听器，与设置事件处理器方法类似。

```
myProperty.addListener(this::processChange);

public void processChange(ObervableValue<? extends String> val, String oldValue, String newValue)
{
    // whatever
}

```

## 10.8 滑动条

> 滑动条是一个允许在一个有限的取值范围中指定某个值得 GUI 组件。

- 滑动条默认为水平的，通过 setOrientation 方法将其设置成垂直的。
- setShowTickMarks 方法，设置是否显示刻度。
- setPadding 方法显示周边的距离。
- 属性 binding 或者通过 getValue 方法获取滑动条的值，设置一个变化监听器。

## 10.9 微调器

> 微调器允许用户从一个预定义的值序列中挑选一个值。是文本框+上下箭头按钮，文本框只会显示当前被选中的一个值。


# 第11章 异常处理

==知识点==

- 错误和异常都是对象，代表非正常情况或无效处理。
- 异常抛出时所输出的信息，提供了方法调用栈踪迹。
- 每个 catch 子句处理一种 try 语句块中抛出的异常。
- 无论 try 语句块正常退出或由于抛出异常而退出，都将执行 finally 子句。
- 如果在一个异常的发生处没有捕捉和处理异常，则该异常将传递给上级调用方法。
- 程序员应该细心地考虑处理异常的时机和位置，否则最好不做任何异常处理。
- 可由 Exception 类或它的后代类派生一个新类来定义一个新的异常。
- 对于检查型异常，如果发生异常的方法不捕捉和处理这个异常，则必须在该方法定义的声明头中包含 throws 子句。
- 流是一个有序的字节序列，它可以用作输入源或作为输出目标。
- System 类中的三种对象引用变量代表标准 IO 流。
- Java 类库包含了许多类，可用于定义具有各种特性的 IO 流。
- 必须明确地关闭输出文件流，否则可能无法正确地保存写入文件中的数据。
- 工具提示为用户提供有关控件作用的信息。
- 当不适合使用某个控件时，就应该禁用它。
- 滚动面板在显示很大的图像或大量的数据时很有用。
- 分隔面板可将两个节点显示成左右或上下形式。
- 列表视图显示一个滚动的、可供选择的选项列表。

> 异常时程序中出现的问题或非正常情况，Java 提供了当异常出现时各种处理方式。

## 11.1 异常

> 错误和异常都是对象，代表非正常情况或无效处理。

- 异常只是代表了一种意外的情况，即异常代表了正常条件下不会发生的情况。
- 处理异常的三种处理方式：
    - 根本不处理异常；
    - 当异常发生时处理异常；
    - 在程序的某个位置集中处理异常。

## 11.2 未捕获的异常

> 如果程序不处理异常，则将非正常地终止执行，并产生关于描述在何处发生什么异常的信息。有关异常的信息，常常有助于跟踪查找问题产生的原因。

- 方法调用栈踪迹信息，如异常的方法名、文件名以及行号。
- 调用栈信息，可以被抛出异常类的方法获得。
    - getMessage 方法返回的字符串，解释了抛出异常的原因；
    - printStackTrace 方法会输出调用栈踪迹，显示了异常发生时所调用的一系列方法。

## 11.3 try-catch 语句

> try-catch 语句可标识出一个可能导致异常的语句块。每个 catch 子句处理一种 try 语句块中抛出的异常。每一个 catch 称为一个异常处理器。

- 例子：11.3A

### 11.3.1 finally 子句

> 无论 try 语句块正常退出或由于抛出异常而退出，都将执行 finally 子句。

- 常利用 finally 子句管理资源或保证一定执行某段代码。

## 11.4 异常的传递

> 如果在一个异常的发生处没有捕捉和处理该异常，则该异常将传递给上级调用方法。

- 直到异常传递出 main 方法，这时将终止程序的执行并产生异常信息。
- 例子：11.4A

> 程序员应该细心地考虑处理异常的时机和位置，否则最好不做任何异常处理。

## 11.5 异常类层次结构

> Object <-- Throwable <-- Error 和 Exception

- 定义在 java.lang 包中，但定义各种异常的子类却分散定义在其他几个包中，继承关系可以跨越包的边界。
- 程序员可以从 Exception 类或它的后台类派生一个新类，定义自己的异常。
- 选择什么类作为父类，由新类所代表的问题和条件决定。
- 例子：11.5A

> 用异常机制还是用正常的程序执行流程来处理这类问题，是一个重要的软件设计决策。

### 11.5.1 检查型与非检查型异常

- 有些异常是检查型的（checked），有些异常是非检查型的（unchecked）。
    - 检查型异常必须由方法捕捉，或者必须在可能抛出或传递异常方法的 throws 子句中列出来。
    - 非检查型异常则不需要是使用 throws 子句。
- Java 中唯一的非检查型异常，是 RuntimeException 类的对象或该类的后代类对象。所有其他的异常，都是检查型异常。
-

> 对于检查型异常，如果发生异常的方法不捕捉和处理这个异常，则必须在该方法定义的声明头中包含 throws 子句。

- main 方法，使用 throws 子句指明 main 方法可能会抛出 OutOfRangeException 异常。main 方法之所以需要 throws 子句，是因为它所抛出的异常类由 Exception 类派生，从而使 OutOfRangeException 异常成为一个检查型异常。

## 11.6 I/O 异常

> 流（stream）是一个有序的字节序列，它可用作输入源或者作为输出目标。

- 一个程序可以同时处理多个输入流和输出流。
- 一个数据存储（如文件）可以作为一个程序的输入流或者输出流，但一般不能同时既是输入流又是输出流。
- 标准的 IO 流有三种，System 类中有三种对象引用变量，in、out和err，都是公有的静态变量，可以通过 System 类直接使用。
    - System.out.println 方法，使用标准输出流。
    - new Scanner(System.in) 对象，支持用各种方法从标准输入流读取数据，其内部对IO异常进行了处理。
    - 默认情况下，标准IO流代表一些实际的设备，System.in 流对象代表键盘，而 System.out 和 System.err 流对象代表显示器屏幕上的一个具体窗口（通常是执行程序的窗口）。

> java.io 包

- Java 标准类库的 java.io 包还提供了许多类，可用于定义具有不同特点的各种流，分别处理文件、内存或者字符串。
- 有些类按照某种方式处理流对象中的数据，例如缓冲数据或者对数据编码。
- 通过适当的方式组合不同的类，可以建立一些适用于实际问题、功能独特的信息流对象。

> IOException 异常类

- IO 类执行的许多操作都可能抛出 IOException 异常或者其后代类。
- IOException 异常是检查型异常。
    - 必须捕获 IOException；
    - 或者所有传递该异常的方法，都必须在方法声明头中的 throws 子句中列出 IOException 异常。

> 程序的健壮性

- 例子：11.6A
- IOException 异常都是检查型异常，所以必须在方法声明头中包含 throws 子句，指明此方法有可能抛出 IOException 异常。
- 恰当处理异常，尤其是处理 IO 操作时更为重要，因为IO操作隐含着一些不是总能预见的潜在问题。

> 必须明确地关闭输出文件流，否则可能无法正确地保存写入文件中的数据。

## 11.7 工具提示与禁用控件

- 工具提示是一小行文本。工具提示为用户提供有关控件作用的信息。
    - ToolTip 类表示。
- 当不适合使用某个控件时，就应该禁用它。
    - setDisable(true) 方法。

## 11.8 滚动面板

> 有时要处理的图像或信息量太大，以至于不能放一个合适的区域中。提供滚动条来改变视图的可是区域。

- 注意，一般不需要设置事件监听器，可自动调整。

## 11.9 分隔面板和列表视图

> 分隔面板可将两个节点显示成左右或上下形式。

- 两个面板和一个分隔条组成。
- setDividerPosition 方法。

> 列表视图显示一个可滚动的、可供选择的选项列表。

- 列表中是一种可观察值（Obervable）。
- ListView 对象。
- 默认为单选择形式，一次只能挑选一个项。也可以多选择模式或者各个项的组合模式。


# 第12章 递归

==知识点==

- 递归是一种方法能够调用自己的编程技术，掌握递归编程的关键是能以递归的思考问题。
- 任何一个递归定义中必须有称为基本情况的非递归定义部分，才能使递归最终结束。
- 数据函数和数学公式常以递归的形式表示。
- 每一次对方法的递归调用，都会创建新的局部变量与参数。
- 详细地跟踪递归处理过程，可以深入剖析递归法求解问题的方式。
- 对于某些问题，递归是最精炼和适当的解法，但对于其他的问题，递归则不如迭代解法直观。
- 汉诺塔解法具有指数复杂性，效率非常低，但是该解法的实现却十分简洁和精炼。
- 分形是一种几何图形，可以递归地描述重复的图案。
- Koch 雪花的面积有限，但周长无限。


## 12.1 递归思想

> 递归是一种方法能够调用自己的编程技术，掌握递归编程的关键是能以递归的思想考虑问题。

- 一般来说，递归是以一种事物自身定义自身的过程，如数字和数字列表的关系。

### 12.1.1 无穷递归

> 任何一个递归定义中，必须有称为基本情况的非递归定义部分，才能使递归最终结束。

- 递归定义部分，则递归永无终止。
- 非递归定义部分，终止递归用途。

### 12.1.2 数学中的递归运算

> 数学函数和数学公式常以递归的形式表示。

## 12.2 递归编程

> 每一次对方法的递归调用，都会创建新的局部变量和参数。

```
// 递归算法实现
public int sum(int num){
    int result;
    if (num ==1)
        result = 1;
    else
        result = num + sum(num-1);
    return result;
}

// 迭代算法实现
sum = 0；
for (int number = 1; number <= num; number++)
    sum += number;

```

- 详细地跟踪递归处理过程，可以深入剖析递归法求解问题的方式。

### 12.2.1 递归与迭代的比较

> 对于某些问题，递归是最精炼和适当的解法，但对于其他问题，递归则不如迭代解法直观。

### 12.2.2 直接递归与间接递归

> 中间层调用，比较难于追踪。

## 12.3 递归的应用

- 汉诺塔问题（Towers of Hanoi）法国数学家 Edouard Lucas于19世纪80年代提出。

> 汉诺塔解法具有指数复杂性，效率非常低，但是该解法的实现却十分简洁和精炼。

## 12.4 平铺图形

- 利用递归来展现图形元素。

## 12.5 分形（fractal）

- 分形式将相同模式的图案以不同的比例和方向构成的一个几何图形。分形的本质决定了它适合用递归来定义。
- 如 Koch 雪花，它是瑞典数学家 Helge von Koch 的名字命名的。Koch 雪花的面积有限，但周长无限。

# 第13章 集合

==知识点==

- 对象具有定义良好的接口，从而成为一种实现集合的完善机制。
- 动态数据结构的大小规模随需要增长和收缩。
- 通过保存和更新对象引用来实现一个链表的管理。
- 通过仔细操作对象引用，可以实现插入和删除操作。
- 动态链表有许多不同的实现。
- 队列是一种可以先进先出方式管理数据的线性集合。
- 栈是一种以后进先出的方式管理数据的线性集合。
- 树是一种以层次结构组织数据的非线性数据结构。
- 图是非线性数据结构，使用常见的边来连接节点。
- Java 集合类 API 定义了几种以不同方式实现的集合类。
- Java 集合类 API 中定义的类为泛型。

> 问题的求解需要组织和管理数据的技术。用于保存信息的对象及实现这类对象的各种方式，这类对象称为集合。如经典的 ArrayList。

## 集合与数据结构

> 集合是一种对象，类似于保存其他对象的存储库。

- 专用于保存元素的对象，并且提供增删改查等管理元素的服务。
- Java 中所有的集合类都是泛型类，所以当创建集合对象时，需要指定它所管理的对象的类型，如 ArrayList<String> 或者 ArrayList<Book>。

## 分离接口与实现

> 集合的一个重要之处是，集合可以用各种方式实现，即保存对象的基础数据结构可以用各种技术实现。

- ArrayList 类，调用数组的相应的方法来实现。
- LinkedList 类，调用链表的相应的方法来实现。

> 抽象数据类型（ADT）是由数据和在该数据上所实施的具体操作构成的集合。

- 一个 ADT 有名称、值域和一组允许执行的操作。
- ADT 之所以被视为抽象数据类型，是因为在 ADT 上可以执行的操作与底层的实现分离开了。即 ADT 如何保存数据和执行方法的细节与其概念分离开了。
- 实际上，“集合”和“抽象数据类型”是可以互换的等同概念。


> 对象非常适合用于定义集合。根据对象的定义，对象本身具有良好的接口，接口的实现就隐含在类中，表达数据的方式和管理数据的操作都封装在对象中。

- 由于对象与软件系统其他组成部分之间的交互受到有效控制，因此这种类型的对象可复用并且可靠。

## 13.2 数据结构的动态表示

- 数组的一个重要限制是，在存续时间，它的大小固定。
- 有时由于程序员事先不知道需要存储多少信息，因此不能确定应该建立多大的数组。如 ArrayList 类，就只能新创建一个更大的数组，将旧数据复制到新的 ArrayList 中保存。这样实现效率较低。

> 动态数据结构的大小规模，随需要增长和收缩。

- 一个动态数据结构用链来实现。
- 利用对象引用作为连接对象间的链，就可以建立适用于各种情况的数据结构。
- 链，实现的数据结构可以具有相当高效的搜索和修改功能。
- 按照这种方法建立的数据结构具有动态性，因为其大小是在使用时动态确定的，而不是在声明时静态确定的。

### 13.2.1 动态结构

> 通过保存和更新对象引用来实现一个链表的管理。

```
// 实例化两个 Node 类对象，并使一个 Node 对象的引用变量 next 指向另一个 Node 对象，从而将两个对象链接在一起。
// 第二个对象的引用变量 next 又指向第三个 Node 对象，以此类推。
// 最后一个节点的引用变量 next 置为 null，表示链表结束。
class Node {
    int info;
    Node next;
}


```

### 13.2.2 动态链表

- 例子 13.2.2A
- 从类外部的角度来说，我们并不关注杂志列表是如何实现的，即并不知道是保存在数组中还是链表中。
- 链表类可以扩展实现插入和删除操作等。

### 13.2.3 其他的动态列表

> 动态链表有许多不同的实现。但可能会带来额外的开销。

```
// 双向链表，每个节点不仅含有一个指向后一节点的引用，而且还有一个指向前一个节点的引用。
// 第一个节点的 prev 指向 null；
// 最后一个节点的 next 指向 null；
class Node {
    int info;
    Node next, prev;
}

// 链表的另一个实现，在链表中增加一个头节点，该头节点中包含了一个指向链表第一节点的前引用和一个指向链表最后节点的后引用，后引用将便于在链表尾部增加新节点。
// 头节点还可以包含其他的信息，如当前节点数等信息。
class ListHeader {
    int count;
    Node front, rear;
}

```

## 13.3 线性集合

> 列表、队列和栈都是线性集合，即这些结构表示的数据是以线性方式组织的。

### 13.3.1 队列

> 队列是一种以先进先出方式管理数据的线性集合。任何一种有等待特点的排列都是一个队列。

- 队列类似于列表，不同之处是队列的元素存取方式有限制，即先进先出。
- 注意，队列的处理是概念级的。
    - 要么队列移动；
    - 要么处理移动；
- 队列的处理：
    - 入队
    - 出队
    - 检测空队列

### 13.3.2 栈

> 栈是一种以后进先出的方式管理数据的线性集合。

- 栈类似于队列，差别在于栈元素在栈的同一端进入或移出的元素，即按后进先出（LIFO）的方式处理。
- 栈的处理：
    - 压栈
    - 出栈
    - 读栈顶
    - 检测空栈
- java.util 包有一个 Stack 类，提供了栈操作。
    - search 方法返回 int 栈中的位置。
- 例子：13.3.2A

## 13.4 非线性数据结构

### 13.4.1 树

> 树是一种以层次结构组织数据的非线性数据结构。常用链表来实现。

- 树是一个非线性数据结构，由一个根节点和构成层次结构的多个节点组成。
    - 除根节点外的所有节点称为内部节点；
    - 没有子节点的节点称为叶子节点。

> 二叉树，每个节点不能有超过两个的子节点。

- 二叉树，只是普通树的子集，但其非常重要，应用广泛。

### 13.4.2 图

> 图是非线性数据结构，使用常见的边来连接节点。常用链表来实现。

- 图是一种非线性数据结构
    - 图没有类似于树根节点那样的初始入口点。
    - 在一个图中，一个节点到另一个节点的连接称为边；
    - 连接一个图内各个节点的边数一般没有限制。
- 当用线性路径和严格的层次结构不足以表示事物间的某种关系时，图是一种表示这类关系的很有用的数据结构。
- 在一个普通的图中，边是双向的。
- 在一个有向图中，每条边只有特定的方向。

## 13.5 Java 集合类 API

- ArrayList 数组实现和 LinkedList 动态链表实现；
    - Vector类 和 Stock 类是早期遗留 API 版本的命名；
- 一些接口用于定义集合操作：
    - List
    - Set，原始集合概念，即没有重复元素的集合。
    - SortedSet
    - Map，可用关键字引用的一组元素。
    - SortedMap

### 13.5.1 泛型

> Java 集合类 API 中的类定义为泛型，是指一个集合所管理的对象的类型，要在实例化该集合对象时才确定。

```
// 实例化一个 String 集合对象；
LinkedList<String> myStringList = new LinkedList<String>();

// 实例化一个 Book 集合对象；
LinkedList<Book> myBookList = new LinkedList<Book>();

```

- 通过指定集合中的存储对象类型，目的：
    - 只有适当类型的对象可以添加到集合中；
    - 由于集合中的对象类型已经建立，因此将一个对象移出集合时不再需要类型转换。

> 泛型保证了集合中对象类型的兼容性。默认为 Object 类型，即集合可以存放任何类型的对象。
